{"version":3,"file":"bundle.js","mappings":"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","sources":["webpack://rafta/./src/helper/index.ts","webpack://rafta/./src/index.ts","webpack://rafta/./src/Rafta.ts"],"sourcesContent":["export function clientChecker() : boolean {\r\n    if(typeof window !== \"undefined\" && typeof document !== \"undefined\") {\r\n        return true\r\n    }else return false;\r\n}\r\n\r\n\r\nexport const debounce = (func: Function , wait : number) => {\r\n    let timeoutId : number | null | undefined;\r\n    return function executedFunction(...args : []) {\r\n        const later = () => {\r\n        timeoutId = null;\r\n        func(...args);\r\n        };\r\n        clearTimeout(timeoutId as number);\r\n        timeoutId = window.setTimeout(later, wait);\r\n    };\r\n};\r\n\r\n\r\nexport function selfClearTimeout(callback : Function , timeout : number) {\r\n    let timer = window.setTimeout(() => {\r\n        callback();\r\n        window.clearTimeout(timer);\r\n    } , timeout);\r\n}\r\n\r\n\r\nexport function deepClone(object : Object) {\r\n    return JSON.parse(JSON.stringify(object));\r\n}\r\n\r\n\r\nfunction detectElementIdentifier(element : HTMLElement) {\r\n    if(element.id) {\r\n        return `#${element.id}`\r\n    }\r\n    else if(element.className) {\r\n        return `.${element.className}`\r\n    }else return \"\";\r\n}\r\n\r\nexport function findDOMPath(element : HTMLElement) : string {\r\n    const pathStack = [];\r\n    \r\n    return (function innerRecursive(parentNode : HTMLElement) {\r\n        if(parentNode?.parentElement) {\r\n            const currentElementName = (() => {\r\n                const elementTag = parentNode.tagName.toLowerCase();\r\n                return `${elementTag}${detectElementIdentifier(parentNode)}`\r\n            })();\r\n\r\n            pathStack.push(currentElementName);\r\n            innerRecursive(parentNode.parentElement);\r\n        }\r\n        return pathStack;\r\n    })(element).reverse().join(\" \");\r\n}\r\n\r\n\r\nexport function findClickPos(e : MouseEvent) : { x : number; y : number } {\r\n    const x = e.clientX;\r\n    const y = e.clientY;\r\n\r\n    return {\r\n        x , \r\n        y\r\n    }\r\n}","import Rafta from \"./Rafta\";\r\nconst raftaIns = new Rafta();\r\nraftaIns.initializer();\r\n","import { debounce, deepClone, findClickPos, findDOMPath, selfClearTimeout } from \"./helper/index\";\r\n\r\ninterface IBrowserDetailsMethod {\r\n    version : number | string;\r\n    name : string;\r\n}\r\n\r\ninterface IUserViewportMethod {\r\n    width : number;\r\n    height : number;\r\n}\r\n\r\ninterface IUserLocation {\r\n    location : {\r\n        latitude : number;\r\n        longitude : number;\r\n    } | \"User denied Geolocation\";\r\n    timestamp : number;\r\n}\r\n\r\ninterface IUserLocationFailed {\r\n    code : number;\r\n    message : string;\r\n}\r\n\r\ntype TUserDevice = \"phone\" | \"desktop\" | \"unknown\";\r\n\r\ninterface IRaftaUserData {\r\n    OSName : string;\r\n    device : TUserDevice;\r\n    isCookieEnable : boolean;\r\n    browser : IBrowserDetailsMethod;\r\n}\r\n\r\ntype TEventType = \"click\" | \"type\" | \"scroll\" | \"mousemove\" | \"resize\" | \"focus\";\r\n\r\ninterface IRaftaEvent {\r\n    event : TEventType;\r\n    data : any;\r\n}\r\n\r\ninterface IRaftaEventStore {\r\n    events : IRaftaEvent[]\r\n}\r\n\r\ninterface IPageInitialData {\r\n    path : string;\r\n    pageHeight : number;\r\n\r\n}\r\n\r\n\r\n\r\nclass Rafta {\r\n    user : IRaftaUserData;\r\n    page : IPageInitialData;\r\n    eventStore : IRaftaEventStore;\r\n    syncTimeout : number;\r\n    syncTimerId : number | undefined;\r\n    focusObserverId : NodeJS.Timer | undefined;\r\n    // mouseEventDebounce : number;\r\n    // resizeEventDebounce : number;\r\n    scrollEventDebounce : number;\r\n    mouseMoveDebounce : number;\r\n    resizeDebounce : number;\r\n    initialScrollEventListenerDelayForAttachment : number;\r\n    shouldPreventServerConnectOnUserSleep : boolean;\r\n\r\n\r\n    constructor() {\r\n        this.user = {\r\n            OSName : \"\",\r\n            browser : { name : \"\" , version : \"\" },\r\n            device : \"unknown\",\r\n            isCookieEnable : false,\r\n        }\r\n\r\n        this.initialScrollEventListenerDelayForAttachment = 100;\r\n        this.syncTimeout = 3000;\r\n        this.scrollEventDebounce = 9;\r\n        this.mouseMoveDebounce = 8;\r\n        this.resizeDebounce = 100;\r\n        this.shouldPreventServerConnectOnUserSleep = true;\r\n\r\n        this.eventStore = { events : [] };\r\n        this.page = { path : \"\" , pageHeight : 0 };\r\n    }\r\n\r\n    getBrowserDetails() : IBrowserDetailsMethod {\r\n        var N= navigator.appName, ua= navigator.userAgent, tem;\r\n        var M= ua.match(/(opera|chrome|safari|firefox|msie|trident)\\/?\\s*(\\.?\\d+(\\.\\d+)*)/i);\r\n        if(M && (tem= ua.match(/version\\/([\\.\\d]+)/i))!= null) {M[2]=tem[1];}\r\n        M= M? [M[1], M[2]]: [N, navigator.appVersion,'-?'];\r\n        \r\n        const [name , version] = M;\r\n        return { name , version }\r\n    }\r\n\r\n    getUserViewport() : IUserViewportMethod {\r\n        return {\r\n            height : window.innerHeight,\r\n            width : window.innerWidth,\r\n        }\r\n    }\r\n\r\n    getUserLocation() : Promise<IUserLocation | IUserLocationFailed> | null {\r\n        if(navigator?.geolocation) {\r\n            return new Promise<IUserLocation | IUserLocationFailed>((resolve , reject) => {\r\n                const onAccessLocationHandler = (e : GeolocationPosition) => {\r\n                    resolve({\r\n                        location : {\r\n                            latitude : e.coords.latitude ,\r\n                            longitude : e.coords.longitude\r\n                        }, \r\n                        timestamp : e.timestamp,\r\n                    })\r\n                }\r\n    \r\n                const onAccessDeniedHandler = (e : GeolocationPositionError) => reject({ code : e.code , message : e.message });\r\n                navigator.geolocation.getCurrentPosition(onAccessLocationHandler , onAccessDeniedHandler)\r\n            })\r\n\r\n\r\n\r\n        }else return null;\r\n    }\r\n\r\n    getUserOSName() : string {\r\n        let userAgent = window.navigator.userAgent,\r\n            platform = window.navigator.platform,\r\n            macosPlatforms = ['Macintosh', 'MacIntel', 'MacPPC', 'Mac68K'],\r\n            windowsPlatforms = ['Win32', 'Win64', 'Windows', 'WinCE'],\r\n            iosPlatforms = ['iPhone', 'iPad', 'iPod'],\r\n            os = \"\";\r\n  \r\n        if (macosPlatforms.indexOf(platform) !== -1) os = 'Mac OS';\r\n        else if (iosPlatforms.indexOf(platform) !== -1) os = 'iOS';\r\n        else if (windowsPlatforms.indexOf(platform) !== -1) os = 'Windows';\r\n        else if (/Android/.test(userAgent)) os = 'Android';\r\n        else if (!os && /Linux/.test(platform)) os = 'Linux';\r\n\r\n        return os;\r\n    }\r\n\r\n    checkCookieStatus() : boolean {\r\n        let cookieEnabled = !!navigator.cookieEnabled;\r\n        \r\n        if (typeof navigator.cookieEnabled === 'undefined' && !cookieEnabled) {\r\n            document.cookie = 'testcookie';\r\n            cookieEnabled = (document.cookie.indexOf('testcookie') != -1) ? true : false;\r\n        }\r\n\r\n        return cookieEnabled;\r\n    }\r\n\r\n    getUserDevice() : TUserDevice {\r\n        if( /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) ) {\r\n            return \"phone\"\r\n        }else return \"desktop\"\r\n    }\r\n\r\n    getPageInitialData() : IPageInitialData {\r\n        const path = location.href;\r\n        const pageHeight = document?.documentElement?.clientHeight;\r\n\r\n        return {\r\n            pageHeight,\r\n            path,\r\n        }\r\n    }\r\n\r\n\r\n    initializer() {\r\n        // send initial user and page data\r\n        // set all event for entire app workflow\r\n        // invoke lifecycle method\r\n\r\n        this.sendInitialData();\r\n        this.attachEventsListener();\r\n        this.mountSync();\r\n    }\r\n\r\n\r\n    sendInitialData() {\r\n\r\n        const page = this.getPageInitialData();\r\n\r\n        const requestPayload = {\r\n            OSName : this.getUserOSName(),\r\n            device : this.getUserDevice(),\r\n            isCookieEnable : this.checkCookieStatus(),\r\n            browser : this.getBrowserDetails(),\r\n            page,\r\n        }\r\n\r\n        this.user = requestPayload;\r\n        this.page = page;\r\n\r\n        // user session id gonna return form server in this connection\r\n    }\r\n\r\n    \r\n    mountSync() {\r\n        console.log('MOUNT');\r\n        \r\n        let timer = window.setInterval(() => {\r\n            if(this.checkIsUserSleep()) {\r\n                this.syncToServer(deepClone(this.eventStore));\r\n                this.clearEventStore();\r\n            }\r\n        } , this.syncTimeout);\r\n        this.syncTimerId = timer;\r\n    }\r\n\r\n\r\n    unMountSync() {\r\n        window.clearInterval(this.syncTimerId);\r\n        this.destroyedEventsListener();\r\n        this.clearEventStore();\r\n    }\r\n\r\n    // setEventStore(newEventStore : IRaftaEventStore) {\r\n    //     this.eventStore = deepClone(newEventStore);\r\n    // }\r\n\r\n    // getEventStore() {\r\n    //     return this.eventStore;\r\n    // }\r\n\r\n    checkIsUserSleep() : boolean {\r\n        if(this.shouldPreventServerConnectOnUserSleep && !this.eventStore.events.length) {\r\n            return false;\r\n        }else return true;\r\n    }\r\n\r\n    private syncToServer(events : IRaftaEventStore) {\r\n        // send data to server\r\n        console.log(events , 'events');\r\n        \r\n    }\r\n    \r\n    private eventDispatcher(targetEvent : IRaftaEvent) {\r\n        const enhancedTargetEventWithTime = {\r\n            ...targetEvent,\r\n            timestamp : Date.now()\r\n        }\r\n        this.eventStore.events.push(enhancedTargetEventWithTime);\r\n    }\r\n\r\n\r\n    private clearEventStore() {\r\n        // clear temp event store in class in unMont lifecycle method and each sync with server\r\n        this.eventStore.events = [];\r\n    }\r\n\r\n    scrollHandler(e : Event) {\r\n        const scrollPx = window.pageYOffset || (document.documentElement || document.body.parentNode || document.body).scrollTop;\r\n\r\n        \r\n        this.eventDispatcher({\r\n            event : \"scroll\",\r\n            data : scrollPx\r\n        })\r\n    }\r\n\r\n    clickHandler(e : MouseEvent) {\r\n        const targetElement = <HTMLElement>e.target;\r\n        \r\n        const selectedElementPath = findDOMPath(targetElement);\r\n        const selectedElementPosition = findClickPos(e);\r\n\r\n        this.eventDispatcher({\r\n            event : \"click\",\r\n            data : {\r\n                path : selectedElementPath,\r\n                position : selectedElementPosition,\r\n            }\r\n        })\r\n\r\n    }\r\n\r\n    typeHandler(e : KeyboardEvent) {\r\n        this.eventDispatcher({\r\n            event : \"type\",\r\n            data : e.key,\r\n        })\r\n    }\r\n\r\n    mouseMoveHandler(e : MouseEvent) {\r\n        \r\n        this.eventDispatcher({\r\n            event : \"mousemove\",\r\n            data : {\r\n                position : {\r\n                    x : e.clientX,\r\n                    y : e.clientY,\r\n                },\r\n            }\r\n        })\r\n    }\r\n\r\n    focusHandler(isFocused : boolean) {\r\n        this.eventDispatcher({\r\n            event : \"focus\",\r\n            data : isFocused,\r\n        })\r\n    }\r\n\r\n    resizeHandler() {\r\n        this.eventDispatcher({\r\n            event : \"resize\",\r\n            data : {\r\n                viewport : this.getUserViewport(),\r\n            }\r\n        })\r\n    }\r\n\r\n    userScrollEvent() {\r\n        selfClearTimeout(() => {\r\n            document.addEventListener(\"scroll\" , debounce(this.scrollHandler.bind(this) , this.scrollEventDebounce));\r\n        } , this.initialScrollEventListenerDelayForAttachment);\r\n    }\r\n\r\n    userClickEvent() {\r\n        document.addEventListener(\"click\" , this.clickHandler.bind(this));\r\n    }\r\n\r\n    userTypeEvent() {\r\n        document.addEventListener(\"keydown\" , this.typeHandler.bind(this));\r\n    }\r\n\r\n    userMouseMoveEvent() {\r\n        document.addEventListener(\"mousemove\" , debounce(this.mouseMoveHandler.bind(this) , this.mouseMoveDebounce));\r\n    }\r\n\r\n    userResizeEvent() {\r\n        window.addEventListener(\"resize\" , debounce(this.resizeHandler.bind(this) , this.resizeDebounce));\r\n    }\r\n\r\n    userFocusEvent() {\r\n        let previousFocusStatus = true; // in default set by 'true' , because when user inter in app , the tab or window is currently active and focused\r\n        let timer = setInterval(() => {\r\n            const hasFocusedOnCurrentDocument = document.hasFocus();\r\n            if(hasFocusedOnCurrentDocument !== previousFocusStatus) {\r\n                this.focusHandler(hasFocusedOnCurrentDocument);\r\n                previousFocusStatus = hasFocusedOnCurrentDocument;\r\n            }\r\n        } , 1000);\r\n\r\n        this.focusObserverId = timer;\r\n\r\n        // return function unsubscribeFocusEvent() {\r\n        //     clearInterval(timer);\r\n        // }\r\n    }\r\n\r\n    attachEventsListener() {\r\n        this.userScrollEvent();\r\n        this.userClickEvent();\r\n        this.userMouseMoveEvent();\r\n        this.userTypeEvent();\r\n        this.userResizeEvent();\r\n        this.userFocusEvent();\r\n    }\r\n\r\n    destroyedEventsListener() {\r\n        // kill illuminate clear de-attach\r\n        document.removeEventListener(\"scroll\" , this.scrollHandler);\r\n        document.removeEventListener(\"click\" , this.clickHandler);\r\n        document.removeEventListener(\"keydown\" , this.typeHandler);\r\n        document.removeEventListener(\"mousemove\" , this.mouseMoveHandler);\r\n        clearInterval(this.focusObserverId)\r\n        \r\n    }\r\n}\r\n\r\nexport default Rafta;\r\n"],"names":["debounce","func","wait","timeoutId","args","later","clearTimeout","window","setTimeout","Rafta","this","user","OSName","browser","name","version","device","isCookieEnable","initialScrollEventListenerDelayForAttachment","syncTimeout","scrollEventDebounce","mouseMoveDebounce","resizeDebounce","shouldPreventServerConnectOnUserSleep","eventStore","events","page","path","pageHeight","tem","N","navigator","appName","ua","userAgent","M","match","appVersion","height","innerHeight","width","innerWidth","geolocation","Promise","resolve","reject","getCurrentPosition","e","location","latitude","coords","longitude","timestamp","code","message","platform","os","indexOf","test","cookieEnabled","document","cookie","href","documentElement","clientHeight","sendInitialData","attachEventsListener","mountSync","getPageInitialData","requestPayload","getUserOSName","getUserDevice","checkCookieStatus","getBrowserDetails","console","log","timer","setInterval","object","checkIsUserSleep","syncToServer","JSON","parse","stringify","clearEventStore","syncTimerId","clearInterval","destroyedEventsListener","length","targetEvent","enhancedTargetEventWithTime","Date","now","push","scrollPx","pageYOffset","body","parentNode","scrollTop","eventDispatcher","event","data","pathStack","targetElement","target","selectedElementPath","innerRecursive","parentElement","currentElementName","elementTag","tagName","toLowerCase","element","id","className","reverse","join","selectedElementPosition","x","clientX","y","clientY","findClickPos","position","key","isFocused","viewport","getUserViewport","callback","timeout","addEventListener","scrollHandler","bind","clickHandler","typeHandler","mouseMoveHandler","resizeHandler","previousFocusStatus","hasFocusedOnCurrentDocument","hasFocus","focusHandler","focusObserverId","userScrollEvent","userClickEvent","userMouseMoveEvent","userTypeEvent","userResizeEvent","userFocusEvent","removeEventListener","initializer"],"sourceRoot":""}